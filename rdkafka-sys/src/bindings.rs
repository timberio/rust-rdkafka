/* automatically generated by rust-bindgen */

type FILE = libc::FILE;
type sockaddr = libc::sockaddr;

pub const RD_KAFKA_VERSION: u32 = 16908799;
pub const RD_KAFKA_DEBUG_CONTEXTS : & 'static [ u8 ; 119usize ] = b"all,generic,broker,topic,metadata,feature,queue,msg,protocol,cgrp,security,fetch,interceptor,plugin,consumer,admin,eos\0" ;
pub const RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE: u32 = 8;
pub const RD_KAFKA_OFFSET_BEGINNING: i32 = -2;
pub const RD_KAFKA_OFFSET_END: i32 = -1;
pub const RD_KAFKA_OFFSET_STORED: i32 = -1000;
pub const RD_KAFKA_OFFSET_INVALID: i32 = -1001;
pub const RD_KAFKA_OFFSET_TAIL_BASE: i32 = -2000;
pub const RD_KAFKA_MSG_F_FREE: u32 = 1;
pub const RD_KAFKA_MSG_F_COPY: u32 = 2;
pub const RD_KAFKA_MSG_F_BLOCK: u32 = 4;
pub const RD_KAFKA_MSG_F_PARTITION: u32 = 8;
pub const RD_KAFKA_PURGE_F_QUEUE: u32 = 1;
pub const RD_KAFKA_PURGE_F_INFLIGHT: u32 = 2;
pub const RD_KAFKA_PURGE_F_NON_BLOCKING: u32 = 4;
pub const RD_KAFKA_EVENT_NONE: u32 = 0;
pub const RD_KAFKA_EVENT_DR: u32 = 1;
pub const RD_KAFKA_EVENT_FETCH: u32 = 2;
pub const RD_KAFKA_EVENT_LOG: u32 = 4;
pub const RD_KAFKA_EVENT_ERROR: u32 = 8;
pub const RD_KAFKA_EVENT_REBALANCE: u32 = 16;
pub const RD_KAFKA_EVENT_OFFSET_COMMIT: u32 = 32;
pub const RD_KAFKA_EVENT_STATS: u32 = 64;
pub const RD_KAFKA_EVENT_CREATETOPICS_RESULT: u32 = 100;
pub const RD_KAFKA_EVENT_DELETETOPICS_RESULT: u32 = 101;
pub const RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT: u32 = 102;
pub const RD_KAFKA_EVENT_ALTERCONFIGS_RESULT: u32 = 103;
pub const RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT: u32 = 104;
pub const RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH: u32 = 256;
extern "C" {
    pub fn rd_kafka_version() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_version_str() -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_type_t {
    RD_KAFKA_PRODUCER = 0,
    RD_KAFKA_CONSUMER = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_timestamp_type_t {
    RD_KAFKA_TIMESTAMP_NOT_AVAILABLE = 0,
    RD_KAFKA_TIMESTAMP_CREATE_TIME = 1,
    RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME = 2,
}
extern "C" {
    pub fn rd_kafka_get_debug_contexts() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_s {
    _unused: [u8; 0],
}
pub type rd_kafka_t = rd_kafka_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_t = rd_kafka_topic_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_conf_s {
    _unused: [u8; 0],
}
pub type rd_kafka_conf_t = rd_kafka_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_conf_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_conf_t = rd_kafka_topic_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_queue_s {
    _unused: [u8; 0],
}
pub type rd_kafka_queue_t = rd_kafka_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_op_s {
    _unused: [u8; 0],
}
pub type rd_kafka_event_t = rd_kafka_op_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_result_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_result_t = rd_kafka_topic_result_s;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_resp_err_t {
    RD_KAFKA_RESP_ERR__BEGIN = -200,
    RD_KAFKA_RESP_ERR__BAD_MSG = -199,
    RD_KAFKA_RESP_ERR__BAD_COMPRESSION = -198,
    RD_KAFKA_RESP_ERR__DESTROY = -197,
    RD_KAFKA_RESP_ERR__FAIL = -196,
    RD_KAFKA_RESP_ERR__TRANSPORT = -195,
    RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = -194,
    RD_KAFKA_RESP_ERR__RESOLVE = -193,
    RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = -192,
    RD_KAFKA_RESP_ERR__PARTITION_EOF = -191,
    RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = -190,
    RD_KAFKA_RESP_ERR__FS = -189,
    RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = -188,
    RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = -187,
    RD_KAFKA_RESP_ERR__INVALID_ARG = -186,
    RD_KAFKA_RESP_ERR__TIMED_OUT = -185,
    RD_KAFKA_RESP_ERR__QUEUE_FULL = -184,
    RD_KAFKA_RESP_ERR__ISR_INSUFF = -183,
    RD_KAFKA_RESP_ERR__NODE_UPDATE = -182,
    RD_KAFKA_RESP_ERR__SSL = -181,
    RD_KAFKA_RESP_ERR__WAIT_COORD = -180,
    RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = -179,
    RD_KAFKA_RESP_ERR__IN_PROGRESS = -178,
    RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = -177,
    RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = -176,
    RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = -175,
    RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = -174,
    RD_KAFKA_RESP_ERR__CONFLICT = -173,
    RD_KAFKA_RESP_ERR__STATE = -172,
    RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = -171,
    RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = -170,
    RD_KAFKA_RESP_ERR__AUTHENTICATION = -169,
    RD_KAFKA_RESP_ERR__NO_OFFSET = -168,
    RD_KAFKA_RESP_ERR__OUTDATED = -167,
    RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = -166,
    RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = -165,
    RD_KAFKA_RESP_ERR__WAIT_CACHE = -164,
    RD_KAFKA_RESP_ERR__INTR = -163,
    RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = -162,
    RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = -161,
    RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = -160,
    RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = -159,
    RD_KAFKA_RESP_ERR__PARTIAL = -158,
    RD_KAFKA_RESP_ERR__READ_ONLY = -157,
    RD_KAFKA_RESP_ERR__NOENT = -156,
    RD_KAFKA_RESP_ERR__UNDERFLOW = -155,
    RD_KAFKA_RESP_ERR__INVALID_TYPE = -154,
    RD_KAFKA_RESP_ERR__RETRY = -153,
    RD_KAFKA_RESP_ERR__PURGE_QUEUE = -152,
    RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = -151,
    RD_KAFKA_RESP_ERR__FATAL = -150,
    RD_KAFKA_RESP_ERR__INCONSISTENT = -149,
    RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = -148,
    RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = -147,
    RD_KAFKA_RESP_ERR__END = -100,
    RD_KAFKA_RESP_ERR_UNKNOWN = -1,
    RD_KAFKA_RESP_ERR_NO_ERROR = 0,
    RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,
    RD_KAFKA_RESP_ERR_INVALID_MSG = 2,
    RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,
    RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,
    RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,
    RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,
    RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,
    RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,
    RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,
    RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,
    RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,
    RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,
    RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,
    RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS = 14,
    RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE = 15,
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP = 16,
    RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,
    RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,
    RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,
    RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,
    RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,
    RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,
    RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,
    RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,
    RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,
    RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,
    RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,
    RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,
    RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,
    RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,
    RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,
    RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,
    RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,
    RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,
    RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,
    RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,
    RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,
    RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,
    RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,
    RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,
    RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,
    RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,
    RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,
    RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,
    RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,
    RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,
    RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,
    RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,
    RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,
    RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,
    RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,
    RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,
    RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,
    RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,
    RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,
    RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,
    RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,
    RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,
    RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,
    RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,
    RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,
    RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,
    RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,
    RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,
    RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,
    RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,
    RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,
    RD_KAFKA_RESP_ERR_END_ALL = 82,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_err_desc {
    pub code: rd_kafka_resp_err_t,
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
}
extern "C" {
    pub fn rd_kafka_get_err_descs(errdescs: *mut *const rd_kafka_err_desc, cntp: *mut usize);
}
extern "C" {
    pub fn rd_kafka_err2str(err: rd_kafka_resp_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_err2name(err: rd_kafka_resp_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_last_error() -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_errno2err(errnox: ::std::os::raw::c_int) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_fatal_error(
        rk: *mut rd_kafka_t,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_test_fatal_error(
        rk: *mut rd_kafka_t,
        err: rd_kafka_resp_err_t,
        reason: *const ::std::os::raw::c_char,
    ) -> rd_kafka_resp_err_t;
}
#[repr(C)]
pub struct rd_kafka_topic_partition_s {
    pub topic: *mut ::std::os::raw::c_char,
    pub partition: i32,
    pub offset: i64,
    pub metadata: *mut ::std::os::raw::c_void,
    pub metadata_size: usize,
    pub opaque: *mut ::std::os::raw::c_void,
    pub err: rd_kafka_resp_err_t,
    pub _private: *mut ::std::os::raw::c_void,
}
pub type rd_kafka_topic_partition_t = rd_kafka_topic_partition_s;
extern "C" {
    pub fn rd_kafka_topic_partition_destroy(rktpar: *mut rd_kafka_topic_partition_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_partition_list_s {
    pub cnt: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
    pub elems: *mut rd_kafka_topic_partition_t,
}
pub type rd_kafka_topic_partition_list_t = rd_kafka_topic_partition_list_s;
extern "C" {
    pub fn rd_kafka_topic_partition_list_new(
        size: ::std::os::raw::c_int,
    ) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_destroy(rkparlist: *mut rd_kafka_topic_partition_list_t);
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_add(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
    ) -> *mut rd_kafka_topic_partition_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_add_range(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const ::std::os::raw::c_char,
        start: i32,
        stop: i32,
    );
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_del(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_del_by_idx(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_copy(
        src: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_set_offset(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
        offset: i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_find(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
    ) -> *mut rd_kafka_topic_partition_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_sort(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                a: *const ::std::os::raw::c_void,
                b: *const ::std::os::raw::c_void,
                cmp_opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        cmp_opaque: *mut ::std::os::raw::c_void,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_vtype_t {
    RD_KAFKA_VTYPE_END = 0,
    RD_KAFKA_VTYPE_TOPIC = 1,
    RD_KAFKA_VTYPE_RKT = 2,
    RD_KAFKA_VTYPE_PARTITION = 3,
    RD_KAFKA_VTYPE_VALUE = 4,
    RD_KAFKA_VTYPE_KEY = 5,
    RD_KAFKA_VTYPE_OPAQUE = 6,
    RD_KAFKA_VTYPE_MSGFLAGS = 7,
    RD_KAFKA_VTYPE_TIMESTAMP = 8,
    RD_KAFKA_VTYPE_HEADER = 9,
    RD_KAFKA_VTYPE_HEADERS = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_headers_s {
    _unused: [u8; 0],
}
pub type rd_kafka_headers_t = rd_kafka_headers_s;
extern "C" {
    pub fn rd_kafka_headers_new(initial_count: usize) -> *mut rd_kafka_headers_t;
}
extern "C" {
    pub fn rd_kafka_headers_destroy(hdrs: *mut rd_kafka_headers_t);
}
extern "C" {
    pub fn rd_kafka_headers_copy(src: *const rd_kafka_headers_t) -> *mut rd_kafka_headers_t;
}
extern "C" {
    pub fn rd_kafka_header_add(
        hdrs: *mut rd_kafka_headers_t,
        name: *const ::std::os::raw::c_char,
        name_size: isize,
        value: *const ::std::os::raw::c_void,
        value_size: isize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_remove(
        hdrs: *mut rd_kafka_headers_t,
        name: *const ::std::os::raw::c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get_last(
        hdrs: *const rd_kafka_headers_t,
        name: *const ::std::os::raw::c_char,
        valuep: *mut *const ::std::os::raw::c_void,
        sizep: *mut usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get(
        hdrs: *const rd_kafka_headers_t,
        idx: usize,
        name: *const ::std::os::raw::c_char,
        valuep: *mut *const ::std::os::raw::c_void,
        sizep: *mut usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get_all(
        hdrs: *const rd_kafka_headers_t,
        idx: usize,
        namep: *mut *const ::std::os::raw::c_char,
        valuep: *mut *const ::std::os::raw::c_void,
        sizep: *mut usize,
    ) -> rd_kafka_resp_err_t;
}
#[repr(C)]
pub struct rd_kafka_message_s {
    pub err: rd_kafka_resp_err_t,
    pub rkt: *mut rd_kafka_topic_t,
    pub partition: i32,
    pub payload: *mut ::std::os::raw::c_void,
    pub len: usize,
    pub key: *mut ::std::os::raw::c_void,
    pub key_len: usize,
    pub offset: i64,
    pub _private: *mut ::std::os::raw::c_void,
}
pub type rd_kafka_message_t = rd_kafka_message_s;
extern "C" {
    pub fn rd_kafka_message_destroy(rkmessage: *mut rd_kafka_message_t);
}
extern "C" {
    pub fn rd_kafka_message_timestamp(
        rkmessage: *const rd_kafka_message_t,
        tstype: *mut rd_kafka_timestamp_type_t,
    ) -> i64;
}
extern "C" {
    pub fn rd_kafka_message_latency(rkmessage: *const rd_kafka_message_t) -> i64;
}
extern "C" {
    pub fn rd_kafka_message_headers(
        rkmessage: *const rd_kafka_message_t,
        hdrsp: *mut *mut rd_kafka_headers_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_message_detach_headers(
        rkmessage: *mut rd_kafka_message_t,
        hdrsp: *mut *mut rd_kafka_headers_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_message_set_headers(
        rkmessage: *mut rd_kafka_message_t,
        hdrs: *mut rd_kafka_headers_t,
    );
}
extern "C" {
    pub fn rd_kafka_header_cnt(hdrs: *const rd_kafka_headers_t) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_msg_status_t {
    RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,
    RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,
    RD_KAFKA_MSG_STATUS_PERSISTED = 2,
}
extern "C" {
    pub fn rd_kafka_message_status(rkmessage: *const rd_kafka_message_t) -> rd_kafka_msg_status_t;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_conf_res_t {
    RD_KAFKA_CONF_UNKNOWN = -2,
    RD_KAFKA_CONF_INVALID = -1,
    RD_KAFKA_CONF_OK = 0,
}
extern "C" {
    pub fn rd_kafka_conf_new() -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_destroy(conf: *mut rd_kafka_conf_t);
}
extern "C" {
    pub fn rd_kafka_conf_dup(conf: *const rd_kafka_conf_t) -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_dup_filter(
        conf: *const rd_kafka_conf_t,
        filter_cnt: usize,
        filter: *mut *const ::std::os::raw::c_char,
    ) -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf(rk: *mut rd_kafka_t) -> *const rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_set(
        conf: *mut rd_kafka_conf_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_set_events(conf: *mut rd_kafka_conf_t, events: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rd_kafka_conf_set_background_event_cb(
        conf: *mut rd_kafka_conf_t,
        event_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                rkev: *mut rd_kafka_event_t,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_dr_cb(
        conf: *mut rd_kafka_conf_t,
        dr_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                payload: *mut ::std::os::raw::c_void,
                len: usize,
                err: rd_kafka_resp_err_t,
                opaque: *mut ::std::os::raw::c_void,
                msg_opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_dr_msg_cb(
        conf: *mut rd_kafka_conf_t,
        dr_msg_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                rkmessage: *const rd_kafka_message_t,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_consume_cb(
        conf: *mut rd_kafka_conf_t,
        consume_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rkmessage: *mut rd_kafka_message_t,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_rebalance_cb(
        conf: *mut rd_kafka_conf_t,
        rebalance_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                partitions: *mut rd_kafka_topic_partition_list_t,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_offset_commit_cb(
        conf: *mut rd_kafka_conf_t,
        offset_commit_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                offsets: *mut rd_kafka_topic_partition_list_t,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_error_cb(
        conf: *mut rd_kafka_conf_t,
        error_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: ::std::os::raw::c_int,
                reason: *const ::std::os::raw::c_char,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_throttle_cb(
        conf: *mut rd_kafka_conf_t,
        throttle_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                broker_name: *const ::std::os::raw::c_char,
                broker_id: i32,
                throttle_time_ms: ::std::os::raw::c_int,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_log_cb(
        conf: *mut rd_kafka_conf_t,
        log_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *const rd_kafka_t,
                level: ::std::os::raw::c_int,
                fac: *const ::std::os::raw::c_char,
                buf: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_stats_cb(
        conf: *mut rd_kafka_conf_t,
        stats_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                json: *mut ::std::os::raw::c_char,
                json_len: usize,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_oauthbearer_token_refresh_cb(
        conf: *mut rd_kafka_conf_t,
        oauthbearer_token_refresh_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                oauthbearer_config: *const ::std::os::raw::c_char,
                opaque: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_socket_cb(
        conf: *mut rd_kafka_conf_t,
        socket_cb: ::std::option::Option<
            unsafe extern "C" fn(
                domain: ::std::os::raw::c_int,
                type_: ::std::os::raw::c_int,
                protocol: ::std::os::raw::c_int,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_connect_cb(
        conf: *mut rd_kafka_conf_t,
        connect_cb: ::std::option::Option<
            unsafe extern "C" fn(
                sockfd: ::std::os::raw::c_int,
                addr: *const sockaddr,
                addrlen: ::std::os::raw::c_int,
                id: *const ::std::os::raw::c_char,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_closesocket_cb(
        conf: *mut rd_kafka_conf_t,
        closesocket_cb: ::std::option::Option<
            unsafe extern "C" fn(
                sockfd: ::std::os::raw::c_int,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_ssl_cert_verify_cb(
        conf: *mut rd_kafka_conf_t,
        ssl_cert_verify_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                broker_name: *const ::std::os::raw::c_char,
                broker_id: i32,
                x509_error: *mut ::std::os::raw::c_int,
                depth: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_char,
                size: usize,
                errstr: *mut ::std::os::raw::c_char,
                errstr_size: usize,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> rd_kafka_conf_res_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_cert_type_t {
    RD_KAFKA_CERT_PUBLIC_KEY = 0,
    RD_KAFKA_CERT_PRIVATE_KEY = 1,
    RD_KAFKA_CERT_CA = 2,
    RD_KAFKA_CERT__CNT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_cert_enc_t {
    RD_KAFKA_CERT_ENC_PKCS12 = 0,
    RD_KAFKA_CERT_ENC_DER = 1,
    RD_KAFKA_CERT_ENC_PEM = 2,
    RD_KAFKA_CERT_ENC__CNT = 3,
}
extern "C" {
    pub fn rd_kafka_conf_set_ssl_cert(
        conf: *mut rd_kafka_conf_t,
        cert_type: rd_kafka_cert_type_t,
        cert_enc: rd_kafka_cert_enc_t,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_set_opaque(
        conf: *mut rd_kafka_conf_t,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rd_kafka_opaque(rk: *const rd_kafka_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rd_kafka_conf_set_default_topic_conf(
        conf: *mut rd_kafka_conf_t,
        tconf: *mut rd_kafka_topic_conf_t,
    );
}
extern "C" {
    pub fn rd_kafka_conf_get(
        conf: *const rd_kafka_conf_t,
        name: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_size: *mut usize,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_get(
        conf: *const rd_kafka_topic_conf_t,
        name: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        dest_size: *mut usize,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_dump(
        conf: *mut rd_kafka_conf_t,
        cntp: *mut usize,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_topic_conf_dump(
        conf: *mut rd_kafka_topic_conf_t,
        cntp: *mut usize,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_conf_dump_free(arr: *mut *const ::std::os::raw::c_char, cnt: usize);
}
extern "C" {
    pub fn rd_kafka_conf_properties_show(fp: *mut FILE);
}
extern "C" {
    pub fn rd_kafka_topic_conf_new() -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_dup(
        conf: *const rd_kafka_topic_conf_t,
    ) -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_default_topic_conf_dup(rk: *mut rd_kafka_t) -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_destroy(topic_conf: *mut rd_kafka_topic_conf_t);
}
extern "C" {
    pub fn rd_kafka_topic_conf_set(
        conf: *mut rd_kafka_topic_conf_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_opaque(
        conf: *mut rd_kafka_topic_conf_t,
        rkt_opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_partitioner_cb(
        topic_conf: *mut rd_kafka_topic_conf_t,
        partitioner: ::std::option::Option<
            unsafe extern "C" fn(
                rkt: *const rd_kafka_topic_t,
                keydata: *const ::std::os::raw::c_void,
                keylen: usize,
                partition_cnt: i32,
                rkt_opaque: *mut ::std::os::raw::c_void,
                msg_opaque: *mut ::std::os::raw::c_void,
            ) -> i32,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_msg_order_cmp(
        topic_conf: *mut rd_kafka_topic_conf_t,
        msg_order_cmp: ::std::option::Option<
            unsafe extern "C" fn(
                a: *const rd_kafka_message_t,
                b: *const rd_kafka_message_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_topic_partition_available(
        rkt: *const rd_kafka_topic_t,
        partition: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_random(
        rkt: *const rd_kafka_topic_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        partition_cnt: i32,
        rkt_opaque: *mut ::std::os::raw::c_void,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_consistent(
        rkt: *const rd_kafka_topic_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        partition_cnt: i32,
        rkt_opaque: *mut ::std::os::raw::c_void,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_consistent_random(
        rkt: *const rd_kafka_topic_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        partition_cnt: i32,
        rkt_opaque: *mut ::std::os::raw::c_void,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_murmur2(
        rkt: *const rd_kafka_topic_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        partition_cnt: i32,
        rkt_opaque: *mut ::std::os::raw::c_void,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_murmur2_random(
        rkt: *const rd_kafka_topic_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        partition_cnt: i32,
        rkt_opaque: *mut ::std::os::raw::c_void,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_new(
        type_: rd_kafka_type_t,
        conf: *mut rd_kafka_conf_t,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> *mut rd_kafka_t;
}
extern "C" {
    pub fn rd_kafka_destroy(rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_destroy_flags(rk: *mut rd_kafka_t, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rd_kafka_name(rk: *const rd_kafka_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_type(rk: *const rd_kafka_t) -> rd_kafka_type_t;
}
extern "C" {
    pub fn rd_kafka_memberid(rk: *const rd_kafka_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_clusterid(
        rk: *mut rd_kafka_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_controllerid(rk: *mut rd_kafka_t, timeout_ms: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    pub fn rd_kafka_topic_new(
        rk: *mut rd_kafka_t,
        topic: *const ::std::os::raw::c_char,
        conf: *mut rd_kafka_topic_conf_t,
    ) -> *mut rd_kafka_topic_t;
}
extern "C" {
    pub fn rd_kafka_topic_destroy(rkt: *mut rd_kafka_topic_t);
}
extern "C" {
    pub fn rd_kafka_topic_name(rkt: *const rd_kafka_topic_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_topic_opaque(rkt: *const rd_kafka_topic_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rd_kafka_poll(
        rk: *mut rd_kafka_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_yield(rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_pause_partitions(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_resume_partitions(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_query_watermark_offsets(
        rk: *mut rd_kafka_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
        low: *mut i64,
        high: *mut i64,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_get_watermark_offsets(
        rk: *mut rd_kafka_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
        low: *mut i64,
        high: *mut i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_offsets_for_times(
        rk: *mut rd_kafka_t,
        offsets: *mut rd_kafka_topic_partition_list_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_mem_free(rk: *mut rd_kafka_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rd_kafka_queue_new(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_destroy(rkqu: *mut rd_kafka_queue_t);
}
extern "C" {
    pub fn rd_kafka_queue_get_main(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_consumer(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_partition(
        rk: *mut rd_kafka_t,
        topic: *const ::std::os::raw::c_char,
        partition: i32,
    ) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_background(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_forward(src: *mut rd_kafka_queue_t, dst: *mut rd_kafka_queue_t);
}
extern "C" {
    pub fn rd_kafka_set_log_queue(
        rk: *mut rd_kafka_t,
        rkqu: *mut rd_kafka_queue_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_queue_length(rkqu: *mut rd_kafka_queue_t) -> usize;
}
extern "C" {
    pub fn rd_kafka_queue_io_event_enable(
        rkqu: *mut rd_kafka_queue_t,
        fd: ::std::os::raw::c_int,
        payload: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn rd_kafka_queue_cb_event_enable(
        rkqu: *mut rd_kafka_queue_t,
        event_cb: ::std::option::Option<
            unsafe extern "C" fn(rk: *mut rd_kafka_t, qev_opaque: *mut ::std::os::raw::c_void),
        >,
        qev_opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn rd_kafka_consume_start(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_consume_start_queue(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
        rkqu: *mut rd_kafka_queue_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_consume_stop(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_seek(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_consume(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: ::std::os::raw::c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consume_batch(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: ::std::os::raw::c_int,
        rkmessages: *mut *mut rd_kafka_message_t,
        rkmessages_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn rd_kafka_consume_callback(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: ::std::os::raw::c_int,
        consume_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rkmessage: *mut rd_kafka_message_t,
                commit_opaque: *mut ::std::os::raw::c_void,
            ),
        >,
        commit_opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_consume_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consume_batch_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: ::std::os::raw::c_int,
        rkmessages: *mut *mut rd_kafka_message_t,
        rkmessages_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn rd_kafka_consume_callback_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: ::std::os::raw::c_int,
        consume_cb: ::std::option::Option<
            unsafe extern "C" fn(
                rkmessage: *mut rd_kafka_message_t,
                commit_opaque: *mut ::std::os::raw::c_void,
            ),
        >,
        commit_opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_offset_store(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_offsets_store(
        rk: *mut rd_kafka_t,
        offsets: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_subscribe(
        rk: *mut rd_kafka_t,
        topics: *const rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_unsubscribe(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_subscription(
        rk: *mut rd_kafka_t,
        topics: *mut *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_consumer_poll(
        rk: *mut rd_kafka_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consumer_close(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_assign(
        rk: *mut rd_kafka_t,
        partitions: *const rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_assignment(
        rk: *mut rd_kafka_t,
        partitions: *mut *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_commit(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        async_: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_commit_message(
        rk: *mut rd_kafka_t,
        rkmessage: *const rd_kafka_message_t,
        async_: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_commit_queue(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        rkqu: *mut rd_kafka_queue_t,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                offsets: *mut rd_kafka_topic_partition_list_t,
                commit_opaque: *mut ::std::os::raw::c_void,
            ),
        >,
        commit_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_committed(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_position(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_produce(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        msgflags: ::std::os::raw::c_int,
        payload: *mut ::std::os::raw::c_void,
        len: usize,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
        msg_opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_producev(rk: *mut rd_kafka_t, ...) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_produce_batch(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        msgflags: ::std::os::raw::c_int,
        rkmessages: *mut rd_kafka_message_t,
        message_cnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_flush(
        rk: *mut rd_kafka_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_purge(
        rk: *mut rd_kafka_t,
        purge_flags: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
#[repr(C)]
pub struct rd_kafka_metadata_broker {
    pub id: i32,
    pub host: *mut ::std::os::raw::c_char,
    pub port: ::std::os::raw::c_int,
}
pub type rd_kafka_metadata_broker_t = rd_kafka_metadata_broker;
#[repr(C)]
pub struct rd_kafka_metadata_partition {
    pub id: i32,
    pub err: rd_kafka_resp_err_t,
    pub leader: i32,
    pub replica_cnt: ::std::os::raw::c_int,
    pub replicas: *mut i32,
    pub isr_cnt: ::std::os::raw::c_int,
    pub isrs: *mut i32,
}
pub type rd_kafka_metadata_partition_t = rd_kafka_metadata_partition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_metadata_topic {
    pub topic: *mut ::std::os::raw::c_char,
    pub partition_cnt: ::std::os::raw::c_int,
    pub partitions: *mut rd_kafka_metadata_partition,
    pub err: rd_kafka_resp_err_t,
}
pub type rd_kafka_metadata_topic_t = rd_kafka_metadata_topic;
#[repr(C)]
pub struct rd_kafka_metadata {
    pub broker_cnt: ::std::os::raw::c_int,
    pub brokers: *mut rd_kafka_metadata_broker,
    pub topic_cnt: ::std::os::raw::c_int,
    pub topics: *mut rd_kafka_metadata_topic,
    pub orig_broker_id: i32,
    pub orig_broker_name: *mut ::std::os::raw::c_char,
}
pub type rd_kafka_metadata_t = rd_kafka_metadata;
extern "C" {
    pub fn rd_kafka_metadata(
        rk: *mut rd_kafka_t,
        all_topics: ::std::os::raw::c_int,
        only_rkt: *mut rd_kafka_topic_t,
        metadatap: *mut *const rd_kafka_metadata,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_metadata_destroy(metadata: *const rd_kafka_metadata);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_group_member_info {
    pub member_id: *mut ::std::os::raw::c_char,
    pub client_id: *mut ::std::os::raw::c_char,
    pub client_host: *mut ::std::os::raw::c_char,
    pub member_metadata: *mut ::std::os::raw::c_void,
    pub member_metadata_size: ::std::os::raw::c_int,
    pub member_assignment: *mut ::std::os::raw::c_void,
    pub member_assignment_size: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct rd_kafka_group_info {
    pub broker: rd_kafka_metadata_broker,
    pub group: *mut ::std::os::raw::c_char,
    pub err: rd_kafka_resp_err_t,
    pub state: *mut ::std::os::raw::c_char,
    pub protocol_type: *mut ::std::os::raw::c_char,
    pub protocol: *mut ::std::os::raw::c_char,
    pub members: *mut rd_kafka_group_member_info,
    pub member_cnt: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_group_list {
    pub groups: *mut rd_kafka_group_info,
    pub group_cnt: ::std::os::raw::c_int,
}
extern "C" {
    pub fn rd_kafka_list_groups(
        rk: *mut rd_kafka_t,
        group: *const ::std::os::raw::c_char,
        grplistp: *mut *const rd_kafka_group_list,
        timeout_ms: ::std::os::raw::c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_group_list_destroy(grplist: *const rd_kafka_group_list);
}
extern "C" {
    pub fn rd_kafka_brokers_add(
        rk: *mut rd_kafka_t,
        brokerlist: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_set_logger(
        rk: *mut rd_kafka_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                rk: *const rd_kafka_t,
                level: ::std::os::raw::c_int,
                fac: *const ::std::os::raw::c_char,
                buf: *const ::std::os::raw::c_char,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_set_log_level(rk: *mut rd_kafka_t, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rd_kafka_log_print(
        rk: *const rd_kafka_t,
        level: ::std::os::raw::c_int,
        fac: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rd_kafka_log_syslog(
        rk: *const rd_kafka_t,
        level: ::std::os::raw::c_int,
        fac: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rd_kafka_outq_len(rk: *mut rd_kafka_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_dump(fp: *mut FILE, rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_thread_cnt() -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_thread_type_t {
    RD_KAFKA_THREAD_MAIN = 0,
    RD_KAFKA_THREAD_BACKGROUND = 1,
    RD_KAFKA_THREAD_BROKER = 2,
}
extern "C" {
    pub fn rd_kafka_wait_destroyed(timeout_ms: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_unittest() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_poll_set_consumer(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
pub type rd_kafka_event_type_t = ::std::os::raw::c_int;
extern "C" {
    pub fn rd_kafka_event_type(rkev: *const rd_kafka_event_t) -> rd_kafka_event_type_t;
}
extern "C" {
    pub fn rd_kafka_event_name(rkev: *const rd_kafka_event_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_event_destroy(rkev: *mut rd_kafka_event_t);
}
extern "C" {
    pub fn rd_kafka_event_message_next(rkev: *mut rd_kafka_event_t) -> *const rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_event_message_array(
        rkev: *mut rd_kafka_event_t,
        rkmessages: *mut *const rd_kafka_message_t,
        size: usize,
    ) -> usize;
}
extern "C" {
    pub fn rd_kafka_event_message_count(rkev: *mut rd_kafka_event_t) -> usize;
}
extern "C" {
    pub fn rd_kafka_event_config_string(
        rkev: *mut rd_kafka_event_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_event_error(rkev: *mut rd_kafka_event_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_event_error_string(
        rkev: *mut rd_kafka_event_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_event_error_is_fatal(rkev: *mut rd_kafka_event_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_event_opaque(rkev: *mut rd_kafka_event_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rd_kafka_event_log(
        rkev: *mut rd_kafka_event_t,
        fac: *mut *const ::std::os::raw::c_char,
        str: *mut *const ::std::os::raw::c_char,
        level: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_event_stats(rkev: *mut rd_kafka_event_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_event_topic_partition_list(
        rkev: *mut rd_kafka_event_t,
    ) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_event_topic_partition(
        rkev: *mut rd_kafka_event_t,
    ) -> *mut rd_kafka_topic_partition_t;
}
pub type rd_kafka_CreateTopics_result_t = rd_kafka_event_t;
pub type rd_kafka_DeleteTopics_result_t = rd_kafka_event_t;
pub type rd_kafka_CreatePartitions_result_t = rd_kafka_event_t;
pub type rd_kafka_AlterConfigs_result_t = rd_kafka_event_t;
pub type rd_kafka_DescribeConfigs_result_t = rd_kafka_event_t;
extern "C" {
    pub fn rd_kafka_event_CreateTopics_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_CreateTopics_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DeleteTopics_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DeleteTopics_result_t;
}
extern "C" {
    pub fn rd_kafka_event_CreatePartitions_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_CreatePartitions_result_t;
}
extern "C" {
    pub fn rd_kafka_event_AlterConfigs_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_AlterConfigs_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DescribeConfigs_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DescribeConfigs_result_t;
}
extern "C" {
    pub fn rd_kafka_queue_poll(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> *mut rd_kafka_event_t;
}
extern "C" {
    pub fn rd_kafka_queue_poll_callback(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type rd_kafka_plugin_f_conf_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        conf: *mut rd_kafka_conf_t,
        plug_opaquep: *mut *mut ::std::os::raw::c_void,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_conf_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        conf: *mut rd_kafka_conf_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_conf_res_t,
>;
pub type rd_kafka_interceptor_f_on_conf_dup_t = ::std::option::Option<
    unsafe extern "C" fn(
        new_conf: *mut rd_kafka_conf_t,
        old_conf: *const rd_kafka_conf_t,
        filter_cnt: usize,
        filter: *mut *const ::std::os::raw::c_char,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_conf_destroy_t = ::std::option::Option<
    unsafe extern "C" fn(ic_opaque: *mut ::std::os::raw::c_void) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        conf: *const rd_kafka_conf_t,
        ic_opaque: *mut ::std::os::raw::c_void,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_destroy_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_send_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_acknowledgement_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_consume_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_commit_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        err: rd_kafka_resp_err_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_request_sent_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        sockfd: ::std::os::raw::c_int,
        brokername: *const ::std::os::raw::c_char,
        brokerid: i32,
        ApiKey: i16,
        ApiVersion: i16,
        CorrId: i32,
        size: usize,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_thread_start_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        thread_type: rd_kafka_thread_type_t,
        thread_name: *const ::std::os::raw::c_char,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_thread_exit_t = ::std::option::Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        thread_type: rd_kafka_thread_type_t,
        thread_name: *const ::std::os::raw::c_char,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t,
>;
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_set(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const ::std::os::raw::c_char,
        on_conf_set: rd_kafka_interceptor_f_on_conf_set_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_dup(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const ::std::os::raw::c_char,
        on_conf_dup: rd_kafka_interceptor_f_on_conf_dup_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_destroy(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const ::std::os::raw::c_char,
        on_conf_destroy: rd_kafka_interceptor_f_on_conf_destroy_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_new(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const ::std::os::raw::c_char,
        on_new: rd_kafka_interceptor_f_on_new_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_destroy(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_destroy: rd_kafka_interceptor_f_on_destroy_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_send(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_send: rd_kafka_interceptor_f_on_send_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_acknowledgement(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_acknowledgement: rd_kafka_interceptor_f_on_acknowledgement_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_consume(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_consume: rd_kafka_interceptor_f_on_consume_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_commit(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_commit: rd_kafka_interceptor_f_on_commit_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_request_sent(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_request_sent: rd_kafka_interceptor_f_on_request_sent_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_thread_start(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_thread_start: rd_kafka_interceptor_f_on_thread_start_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_thread_exit(
        rk: *mut rd_kafka_t,
        ic_name: *const ::std::os::raw::c_char,
        on_thread_exit: rd_kafka_interceptor_f_on_thread_exit_t,
        ic_opaque: *mut ::std::os::raw::c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_result_error(
        topicres: *const rd_kafka_topic_result_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_result_error_string(
        topicres: *const rd_kafka_topic_result_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_topic_result_name(
        topicres: *const rd_kafka_topic_result_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_admin_op_t {
    RD_KAFKA_ADMIN_OP_ANY = 0,
    RD_KAFKA_ADMIN_OP_CREATETOPICS = 1,
    RD_KAFKA_ADMIN_OP_DELETETOPICS = 2,
    RD_KAFKA_ADMIN_OP_CREATEPARTITIONS = 3,
    RD_KAFKA_ADMIN_OP_ALTERCONFIGS = 4,
    RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS = 5,
    RD_KAFKA_ADMIN_OP__CNT = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_AdminOptions_s {
    _unused: [u8; 0],
}
pub type rd_kafka_AdminOptions_t = rd_kafka_AdminOptions_s;
extern "C" {
    pub fn rd_kafka_AdminOptions_new(
        rk: *mut rd_kafka_t,
        for_api: rd_kafka_admin_op_t,
    ) -> *mut rd_kafka_AdminOptions_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_destroy(options: *mut rd_kafka_AdminOptions_t);
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_request_timeout(
        options: *mut rd_kafka_AdminOptions_t,
        timeout_ms: ::std::os::raw::c_int,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_operation_timeout(
        options: *mut rd_kafka_AdminOptions_t,
        timeout_ms: ::std::os::raw::c_int,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_validate_only(
        options: *mut rd_kafka_AdminOptions_t,
        true_or_false: ::std::os::raw::c_int,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_broker(
        options: *mut rd_kafka_AdminOptions_t,
        broker_id: i32,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_opaque(
        options: *mut rd_kafka_AdminOptions_t,
        ev_opaque: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_NewTopic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_NewTopic_t = rd_kafka_NewTopic_s;
extern "C" {
    pub fn rd_kafka_NewTopic_new(
        topic: *const ::std::os::raw::c_char,
        num_partitions: ::std::os::raw::c_int,
        replication_factor: ::std::os::raw::c_int,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> *mut rd_kafka_NewTopic_t;
}
extern "C" {
    pub fn rd_kafka_NewTopic_destroy(new_topic: *mut rd_kafka_NewTopic_t);
}
extern "C" {
    pub fn rd_kafka_NewTopic_destroy_array(
        new_topics: *mut *mut rd_kafka_NewTopic_t,
        new_topic_cnt: usize,
    );
}
extern "C" {
    pub fn rd_kafka_NewTopic_set_replica_assignment(
        new_topic: *mut rd_kafka_NewTopic_t,
        partition: i32,
        broker_ids: *mut i32,
        broker_id_cnt: usize,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_NewTopic_set_config(
        new_topic: *mut rd_kafka_NewTopic_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_CreateTopics(
        rk: *mut rd_kafka_t,
        new_topics: *mut *mut rd_kafka_NewTopic_t,
        new_topic_cnt: usize,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_CreateTopics_result_topics(
        result: *const rd_kafka_CreateTopics_result_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_DeleteTopic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_DeleteTopic_t = rd_kafka_DeleteTopic_s;
extern "C" {
    pub fn rd_kafka_DeleteTopic_new(
        topic: *const ::std::os::raw::c_char,
    ) -> *mut rd_kafka_DeleteTopic_t;
}
extern "C" {
    pub fn rd_kafka_DeleteTopic_destroy(del_topic: *mut rd_kafka_DeleteTopic_t);
}
extern "C" {
    pub fn rd_kafka_DeleteTopic_destroy_array(
        del_topics: *mut *mut rd_kafka_DeleteTopic_t,
        del_topic_cnt: usize,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteTopics(
        rk: *mut rd_kafka_t,
        del_topics: *mut *mut rd_kafka_DeleteTopic_t,
        del_topic_cnt: usize,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteTopics_result_topics(
        result: *const rd_kafka_DeleteTopics_result_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_NewPartitions_s {
    _unused: [u8; 0],
}
pub type rd_kafka_NewPartitions_t = rd_kafka_NewPartitions_s;
extern "C" {
    pub fn rd_kafka_NewPartitions_new(
        topic: *const ::std::os::raw::c_char,
        new_total_cnt: usize,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> *mut rd_kafka_NewPartitions_t;
}
extern "C" {
    pub fn rd_kafka_NewPartitions_destroy(new_parts: *mut rd_kafka_NewPartitions_t);
}
extern "C" {
    pub fn rd_kafka_NewPartitions_destroy_array(
        new_parts: *mut *mut rd_kafka_NewPartitions_t,
        new_parts_cnt: usize,
    );
}
extern "C" {
    pub fn rd_kafka_NewPartitions_set_replica_assignment(
        new_parts: *mut rd_kafka_NewPartitions_t,
        new_partition_idx: i32,
        broker_ids: *mut i32,
        broker_id_cnt: usize,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_CreatePartitions(
        rk: *mut rd_kafka_t,
        new_parts: *mut *mut rd_kafka_NewPartitions_t,
        new_parts_cnt: usize,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_CreatePartitions_result_topics(
        result: *const rd_kafka_CreatePartitions_result_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_ConfigSource_t {
    RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,
    RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,
    RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,
    RD_KAFKA_CONFIG_SOURCE__CNT = 6,
}
extern "C" {
    pub fn rd_kafka_ConfigSource_name(
        confsource: rd_kafka_ConfigSource_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_ConfigEntry_s {
    _unused: [u8; 0],
}
pub type rd_kafka_ConfigEntry_t = rd_kafka_ConfigEntry_s;
extern "C" {
    pub fn rd_kafka_ConfigEntry_name(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_value(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_source(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> rd_kafka_ConfigSource_t;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_read_only(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_default(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_sensitive(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_synonym(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_synonyms(
        entry: *const rd_kafka_ConfigEntry_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_ConfigEntry_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rd_kafka_ResourceType_t {
    RD_KAFKA_RESOURCE_UNKNOWN = 0,
    RD_KAFKA_RESOURCE_ANY = 1,
    RD_KAFKA_RESOURCE_TOPIC = 2,
    RD_KAFKA_RESOURCE_GROUP = 3,
    RD_KAFKA_RESOURCE_BROKER = 4,
    RD_KAFKA_RESOURCE__CNT = 5,
}
extern "C" {
    pub fn rd_kafka_ResourceType_name(
        restype: rd_kafka_ResourceType_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_ConfigResource_s {
    _unused: [u8; 0],
}
pub type rd_kafka_ConfigResource_t = rd_kafka_ConfigResource_s;
extern "C" {
    pub fn rd_kafka_ConfigResource_new(
        restype: rd_kafka_ResourceType_t,
        resname: *const ::std::os::raw::c_char,
    ) -> *mut rd_kafka_ConfigResource_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_destroy(config: *mut rd_kafka_ConfigResource_t);
}
extern "C" {
    pub fn rd_kafka_ConfigResource_destroy_array(
        config: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: usize,
    );
}
extern "C" {
    pub fn rd_kafka_ConfigResource_set_config(
        config: *mut rd_kafka_ConfigResource_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_configs(
        config: *const rd_kafka_ConfigResource_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_ConfigEntry_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_type(
        config: *const rd_kafka_ConfigResource_t,
    ) -> rd_kafka_ResourceType_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_name(
        config: *const rd_kafka_ConfigResource_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_error(
        config: *const rd_kafka_ConfigResource_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_error_string(
        config: *const rd_kafka_ConfigResource_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rd_kafka_AlterConfigs(
        rk: *mut rd_kafka_t,
        configs: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: usize,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_AlterConfigs_result_resources(
        result: *const rd_kafka_AlterConfigs_result_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_ConfigResource_t;
}
extern "C" {
    pub fn rd_kafka_DescribeConfigs(
        rk: *mut rd_kafka_t,
        configs: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: usize,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DescribeConfigs_result_resources(
        result: *const rd_kafka_DescribeConfigs_result_t,
        cntp: *mut usize,
    ) -> *mut *const rd_kafka_ConfigResource_t;
}
extern "C" {
    pub fn rd_kafka_oauthbearer_set_token(
        rk: *mut rd_kafka_t,
        token_value: *const ::std::os::raw::c_char,
        md_lifetime_ms: i64,
        md_principal_name: *const ::std::os::raw::c_char,
        extensions: *mut *const ::std::os::raw::c_char,
        extension_size: usize,
        errstr: *mut ::std::os::raw::c_char,
        errstr_size: usize,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_oauthbearer_set_token_failure(
        rk: *mut rd_kafka_t,
        errstr: *const ::std::os::raw::c_char,
    ) -> rd_kafka_resp_err_t;
}
